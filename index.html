<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Slope Game</title>
<style>
  body {
    margin: 0;
    padding: 0;
    height: 100vh;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    color: white;
  }
  #gameContainer {
    position: relative;
    width: 800px;
    height: 600px;
    background: #000;
    border: 3px solid #00ff00;
    overflow: hidden;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  #ui {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 24px;
    z-index: 10;
    text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
  }
  #score {
    color: #00ff00;
    font-weight: bold;
  }
  #gameOverScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }
  #gameOverScreen.show {
    display: flex;
  }
  #gameOverScreen h2 {
    font-size: 48px;
    color: #ff0000;
    margin: 0 0 20px 0;
  }
  #finalScore {
    font-size: 32px;
    color: #00ff00;
    margin-bottom: 30px;
  }
  button {
    padding: 15px 40px;
    font-size: 20px;
    background: #00ff00;
    color: #000;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s;
  }
  button:hover {
    background: #00cc00;
    transform: scale(1.05);
  }
  .info {
    margin-top: 20px;
    font-size: 16px;
    color: #aaa;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    Score: <span id="score">0</span><br>
    Speed: <span id="speed">1.0x</span>
  </div>
  <div id="gameOverScreen">
    <h2>GAME OVER</h2>
    <div id="finalScore">Score: 0</div>
    <button onclick="restartGame()">RESTART</button>
  </div>
</div>
<div class="info">
  Use ARROW KEYS or WASD to move left/right • Avoid obstacles • Collect yellow stars for points
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreEl = document.getElementById('finalScore');
canvas.width = 800;
canvas.height = 600;
let score = 0;
let gameRunning = true;
let gameSpeed = 5;
let slopeOffset = 0;
// Player ball
const player = {
  x: canvas.width / 2,
  y: canvas.height - 80,
  radius: 15,
  speed: 0,
  maxSpeed: 8
};
// Game objects
let obstacles = [];
let powerUps = [];
let particles = [];
// Slope parameters
const slopeWidth = 150;
const slopeAngle = 0.3;
// Input handling
const keys = {};
window.addEventListener('keydown', (e) => {
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', (e) => {
  keys[e.key.toLowerCase()] = false;
});
// Spawn obstacle
function spawnObstacle() {
  const x = Math.random() * (slopeWidth - 40) + (canvas.width - slopeWidth) / 2;
  obstacles.push({
    x: x,
    y: -50,
    width: 40,
    height: 40,
    color: '#ff0000'
  });
}
// Spawn power-up
function spawnPowerUp() {
  const x = Math.random() * (slopeWidth - 30) + (canvas.width - slopeWidth) / 2;
  powerUps.push({
    x: x,
    y: -50,
    radius: 12,
    color: '#ffff00',
    active: true
  });
}
// Spawn particles
function createParticles(x, y, color, count = 8) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count;
    particles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * 4,
      vy: Math.sin(angle) * 4,
      life: 30,
      color: color
    });
  }
}
// Draw slope
function drawSlope() {
  const leftX = (canvas.width - slopeWidth) / 2;
  const rightX = leftX + slopeWidth;
  ctx.fillStyle = '#333333';
  ctx.beginPath();
  ctx.moveTo(leftX, 0);
  ctx.lineTo(rightX, 0);
  ctx.lineTo(rightX + 200, canvas.height);
  ctx.lineTo(leftX - 200, canvas.height);
  ctx.closePath();
  ctx.fill();
  // Slope grid lines
  ctx.strokeStyle = '#555555';
  ctx.lineWidth = 1;
  for (let i = 0; i < canvas.height; i += 40) {
    const adjustedOffset = (slopeOffset + i) % 40;
    ctx.beginPath();
    ctx.moveTo(leftX - adjustedOffset * slopeAngle, i);
    ctx.lineTo(rightX - adjustedOffset * slopeAngle, i);
    ctx.stroke();
  }
}
// Draw player
function drawPlayer() {
  const grad = ctx.createRadialGradient(player.x, player.y, 5, player.x, player.y, player.radius);
  grad.addColorStop(0, '#00ff00');
  grad.addColorStop(1, '#00aa00');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
  ctx.fill();
  // Glow
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius + 8, 0, Math.PI * 2);
  ctx.stroke();
}
// Draw obstacles
function drawObstacles() {
  obstacles.forEach(obs => {
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
    // Glow
    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
    ctx.shadowBlur = 10;
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
    ctx.shadowColor = 'transparent';
  });
}
// Draw power-ups
function drawPowerUps() {
  powerUps.forEach(pu => {
    if (!pu.active) return;
    ctx.fillStyle = pu.color;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y, pu.radius, 0, Math.PI * 2);
    ctx.fill();
    // Star effect
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y, pu.radius + 6, 0, Math.PI * 2);
    ctx.stroke();
  });
}
// Draw particles
function drawParticles() {
  particles.forEach((p, i) => {
    ctx.globalAlpha = p.life / 30;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });
}
// Update game
function update() {
  if (!gameRunning) return;
  // Player movement
  let moveX = 0;
  if (keys['arrowleft'] || keys['a']) moveX = -player.maxSpeed;
  if (keys['arrowright'] || keys['d']) moveX = player.maxSpeed;
  player.x += moveX;
  // Keep player in bounds (slope width)
  const leftBound = (canvas.width - slopeWidth) / 2 + player.radius;
  const rightBound = (canvas.width + slopeWidth) / 2 - player.radius;
  player.x = Math.max(leftBound, Math.min(rightBound, player.x));
  // Move slope down (camera follows ball)
  slopeOffset += gameSpeed;
  // Increase difficulty over time
  gameSpeed = 5 + (score / 1000) * 3;
  speedEl.textContent = (gameSpeed / 5).toFixed(1) + 'x';
  // Update obstacles
  obstacles.forEach((obs, i) => {
    obs.y += gameSpeed;
    // Check collision with player
    if (obs.x < player.x + player.radius &&
        obs.x + obs.width > player.x - player.radius &&
        obs.y < player.y + player.radius &&
        obs.y + obs.height > player.y - player.radius) {
      endGame();
    }
    if (obs.y > canvas.height) {
      obstacles.splice(i, 1);
    }
  });
  // Update power-ups
  powerUps.forEach((pu, i) => {
    pu.y += gameSpeed;
    // Check collision with player
    if (pu.active && Math.hypot(pu.x - player.x, pu.y - player.y) < player.radius + pu.radius) {
      pu.active = false;
      score += 50;
      scoreEl.textContent = score;
      createParticles(pu.x, pu.y, '#ffff00');
    }
    if (pu.y > canvas.height) {
      powerUps.splice(i, 1);
    }
  });
  // Update particles
  particles.forEach((p, i) => {
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  });
  // Spawn new objects
  if (Math.random() < 0.02) spawnObstacle();
  if (Math.random() < 0.01) spawnPowerUp();
  // Score from surviving
  score++;
  scoreEl.textContent = score;
}
// Draw game
function draw() {
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawSlope();
  drawObstacles();
  drawPowerUps();
  drawPlayer();
  drawParticles();
}
// End game
function endGame() {
  gameRunning = false;
  gameOverScreen.classList.add('show');
  finalScoreEl.textContent = 'Score: ' + score;
}
// Restart game
function restartGame() {
  score = 0;
  gameSpeed = 5;
  slopeOffset = 0;
  gameRunning = true;
  obstacles = [];
  powerUps = [];
  particles = [];
  player.x = canvas.width / 2;
  player.y = canvas.height - 80;
  gameOverScreen.classList.remove('show');
  scoreEl.textContent = '0';
  speedEl.textContent = '1.0x';
  gameLoop();
}
// Main game loop
function gameLoop() {
  update();
  draw();
  if (gameRunning) {
    requestAnimationFrame(gameLoop);
  }
}
// Start game
gameLoop();
</script>
</body>
</html>